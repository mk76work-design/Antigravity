<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack to Goal</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud {
            color: white;
            text-shadow: 1px 1px 2px black;
            font-size: 24px;
            font-weight: bold;
        }

        #message-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 100;
        }

        h1 {
            color: #ffcc00;
            font-size: 60px;
            margin: 0;
            text-shadow: 2px 2px 4px #000;
        }

        button {
            pointer-events: auto;
            padding: 15px 40px;
            font-size: 24px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px #990000;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 #990000;
        }

        button.next {
            background: #44cc44;
            box-shadow: 0 4px #007700;
        }

        button.next:active {
            box-shadow: 0 0 #007700;
        }

        #guide {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #aaa;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }

        #blocks-left {
            color: #44ccff;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div class="hud">
            <div>Level: <span id="level-num">1</span> / 10</div>
            <div id="blocks-left">Blocks Left: 10</div>
        </div>
        <div id="message-area">
            <h1 id="msg-text">CLEAR!</h1>
            <button id="action-btn">Next Level</button>
        </div>
        <button onclick="resetLevel()"
            style="position:absolute; top:10px; right:20px; padding:10px 20px; font-size:16px;">Retry (R)</button>
    </div>
    <div id="guide">Click to spawn boxes. Stack them to reach the GREEN area!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            Composite = Matter.Composite,
            Events = Matter.Events,
            Vector = Matter.Vector,
            Mouse = Matter.Mouse;

        let engine, render, runner, world;
        let currentLevel = 1;
        const MAX_LEVEL = 10;
        let goalArea;
        let winTimer = 0;
        let gameActive = true;
        let maxBlocks = 15;
        let currentBlocks = 0;

        window.onload = function () {
            initGame();
            loadLevel(currentLevel);
        };

        function initGame() {
            engine = Engine.create();
            world = engine.world;

            render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: '#222'
                }
            });

            // マウス操作（クリック位置取得用）
            const mouse = Mouse.create(render.canvas);
            render.mouse = mouse; // Matter.jsのマウスを登録（座標変換用）

            // クリックイベント
            document.addEventListener('mousedown', (e) => {
                if (!gameActive) return;

                // UI上のクリックなら無視
                if (e.target.tagName === 'BUTTON') return;

                // 残弾数チェック
                if (currentBlocks >= maxBlocks) return;

                // ゴールエリア内かどうかのチェック（ゴール内生成禁止）
                const clickPos = { x: e.clientX, y: e.clientY };
                if (Matter.Bounds.contains(goalArea.bounds, clickPos)) {
                    // ゴール内には置けないエフェクト（今回は単純に無視）
                    return;
                }

                spawnBox(clickPos.x, clickPos.y);
            });

            // 勝利判定ループ
            Events.on(engine, 'beforeUpdate', function () {
                if (!gameActive || !goalArea) return;

                let winning = false;
                const bodies = Composite.allBodies(world);

                for (let body of bodies) {
                    if (body.isStatic || body.isSensor) continue; // 壁やゴール自体は無視

                    // ゴールと重なっているか
                    if (Matter.Bounds.overlaps(body.bounds, goalArea.bounds)) {
                        // 速度チェック（安定しているか）
                        if (body.speed < 0.5) {
                            winning = true;
                            // 視覚効果：触れている箱を少し光らせる
                            body.render.opacity = 1;
                        }
                    }
                }

                if (winning) {
                    winTimer++;
                    goalArea.render.fillStyle = `rgba(0, 255, 0, ${0.3 + (winTimer / 180) * 0.7})`; // 緑が濃くなる
                    if (winTimer > 180) { // 3秒間キープ（60fps * 3）
                        levelClear();
                    }
                } else {
                    winTimer = 0;
                    goalArea.render.fillStyle = 'rgba(0, 255, 0, 0.3)';
                }
            });

            window.addEventListener('resize', () => {
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'r' || e.key === 'R') resetLevel();
            });

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
        }

        function spawnBox(x, y) {
            const size = 40;
            const color = `hsl(${Math.random() * 360}, 70%, 50%)`;
            const box = Bodies.rectangle(x, y, size, size, {
                restitution: 0.5,
                friction: 0.5,
                render: { fillStyle: color }
            });
            Composite.add(world, box);

            currentBlocks++;
            updateUI();
        }

        function updateUI() {
            document.getElementById('blocks-left').innerText = `Blocks Left: ${maxBlocks - currentBlocks}`;
            document.getElementById('level-num').innerText = currentLevel;
        }

        function loadLevel(level) {
            Composite.clear(world);
            engine.events = {};
            // ※Composite.clearした後はbeforeUpdateイベントも消える場合があるので再登録が必要だが、
            // Matter.jsの仕様によりengineに紐づくイベントは残る場合と消える場合がある。
            // 念のためinitGame内のイベントはそのまま、ここではワールドの中身だけリセットする。

            const w = window.innerWidth;
            const h = window.innerHeight;

            // 外枠
            const ground = Bodies.rectangle(w / 2, h, w, 60, { isStatic: true, render: { fillStyle: '#444' } });
            const leftW = Bodies.rectangle(0, h / 2, 60, h, { isStatic: true, render: { fillStyle: '#444' } });
            const rightW = Bodies.rectangle(w, h / 2, 60, h, { isStatic: true, render: { fillStyle: '#444' } });
            Composite.add(world, [ground, leftW, rightW]);

            currentBlocks = 0;
            winTimer = 0;
            gameActive = true;
            document.getElementById('message-area').style.display = 'none';

            // レベルデザイン
            createLevelDesign(level, w, h);
            updateUI();
        }

        function createLevelDesign(level, w, h) {
            // デフォルト設定
            maxBlocks = 15;
            let gx = w / 2, gy = h / 2, gw = 100, gh = 100;
            let obstacles = [];

            switch (level) {
                case 1: // 基礎：少し高いところにあるゴール
                    gx = w / 2; gy = h - 200;
                    maxBlocks = 10;
                    break;
                case 2: // 壁の向こう側
                    gx = w - 100; gy = h - 100;
                    obstacles.push(Bodies.rectangle(w / 2, h - 100, 20, 200, { isStatic: true, render: { fillStyle: '#888' } }));
                    break;
                case 3: // 浮島（バランスが必要）
                    gx = w / 2; gy = h - 400;
                    // 土台となる浮島
                    obstacles.push(Bodies.rectangle(w / 2, h - 200, 200, 20, { isStatic: true, render: { fillStyle: '#888' } }));
                    break;
                case 4: // シーソー
                    gx = w - 100; gy = h - 300;
                    const bar = Bodies.rectangle(w / 2, h - 200, 400, 20, { render: { fillStyle: '#d44' } });
                    const pivot = Constraint.create({ pointA: { x: w / 2, y: h - 200 }, bodyB: bar, length: 0, stiffness: 1 });
                    obstacles.push(bar, pivot); // Constraintを使うために定義が必要だが今回は簡易版でConstraint除外
                    // Constraintは今回は使わない方針で（前のコードの依存を消すため）、静的障害物で構成
                    obstacles.push(Bodies.rectangle(w / 2, h - 200, 20, 20, { isStatic: true })); // シーソーの中心点だけ
                    obstacles.push(Bodies.rectangle(w / 2, h - 220, 400, 20, { density: 0.001 })); // 物理演算バー
                    break;
                case 5: // 狭い穴
                    gx = w / 2; gy = h - 60;
                    obstacles.push(Bodies.rectangle(w / 2 - 50, h - 150, 20, 300, { isStatic: true }));
                    obstacles.push(Bodies.rectangle(w / 2 + 50, h - 150, 20, 300, { isStatic: true }));
                    // 蓋
                    obstacles.push(Bodies.rectangle(w / 2, h - 310, 150, 20, { isStatic: true }));
                    break;
                case 6: // 階段
                    gx = w - 100; gy = h - 400;
                    for (let i = 0; i < 5; i++) {
                        obstacles.push(Bodies.rectangle(100 + i * 100, h - (i * 60), 100, 20, { isStatic: true }));
                    }
                    break;
                case 7: // 不安定な足場（回転体なし）
                    gx = w / 2; gy = 100; // 天井付近
                    obstacles.push(Bodies.rectangle(w / 2, h / 2, 100, 20, { isStatic: true }));
                    break;
                case 8: // ピンボール風
                    gx = w - 100; gy = h - 100;
                    for (let i = 0; i < 5; i++) {
                        obstacles.push(Bodies.circle(100 + i * 150, h / 2 + (i % 2) * 100, 40, { isStatic: true }));
                    }
                    break;
                case 9: // 超高層ビル
                    gx = w / 2; gy = 150;
                    maxBlocks = 25;
                    // 狭い土台
                    obstacles.push(Bodies.rectangle(w / 2, h - 50, 100, 20, { isStatic: true }));
                    break;
                case 10: // 最終関門
                    gx = w / 2; gy = h / 2;
                    // 周囲を囲まれた箱（上から入れるしかない）
                    obstacles.push(Bodies.rectangle(w / 2 - 60, h / 2, 20, 150, { isStatic: true }));
                    obstacles.push(Bodies.rectangle(w / 2 + 60, h / 2, 20, 150, { isStatic: true }));
                    obstacles.push(Bodies.rectangle(w / 2, h / 2 + 75, 140, 20, { isStatic: true }));
                    break;
            }

            // ゴール生成
            goalArea = Bodies.rectangle(gx, gy, gw, gh, {
                isStatic: true,
                isSensor: true,
                render: {
                    fillStyle: 'rgba(0, 255, 0, 0.3)',
                    strokeStyle: '#0f0',
                    lineWidth: 2
                }
            });
            Composite.add(world, [goalArea, ...obstacles]);
        }

        function levelClear() {
            gameActive = false;
            const msg = document.getElementById('message-area');
            const txt = document.getElementById('msg-text');
            const btn = document.getElementById('action-btn');

            msg.style.display = 'block';

            if (currentLevel >= MAX_LEVEL) {
                txt.innerText = "ALL CLEARED!";
                btn.innerText = "Play Again";
                btn.className = "next";
                btn.onclick = () => { currentLevel = 1; loadLevel(1); };
            } else {
                txt.innerText = "STAGE CLEAR!";
                btn.innerText = "Next Level";
                btn.className = "next";
                btn.onclick = () => { currentLevel++; loadLevel(currentLevel); };
            }
        }

        function resetLevel() {
            loadLevel(currentLevel);
        }
    </script>
</body>

</html>